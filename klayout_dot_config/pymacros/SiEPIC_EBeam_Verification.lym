<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>SiEPIC-EBeam: Verification and Netlist generation</description>
 <version>0.1.2</version>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>true</show-in-menu>
 <group-name>SiEPIC</group-name>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># Python script
# SiEPIC_EBeam_Verification

"""
This file is part of the SiEPIC_EBeam_PDK
by Lukas Chrostowski (c) 2015

This Python file implements layout verification and netlist extraction


Version history:

0.1.1 Lukas Chrostowski 2015/11/11
 - Optical_net class
 - find all SiLayer paths and waveguides, and save optical net vertices 
 - find all PinRec paths
 - find all DevRec polygons and boxes
 - check_waveguides
   - waveguide bend minimum
   - paths with corners (more than 2 points)
   - bend radius less than specified
 - error marker layer and class; clear errors
0.1.2 Lukas Chrostowski 2015/11/12
 - determining where pins/waveguides overlap to generate a netlist
 - initial Spice output for components including waveguides and nets.
 - check nets &amp; components
   - incorrect number of nets connected to a component (disconnected, or too many)
 
"""


import pya
import math
import numpy
import math
import string

# one for each instance of the components
class Optical_component:
    n = 0
    def __init__(self, component, instance, x, y, flip, rotate, library):
        Optical_component.n += 1
        self.n = Optical_component.n # component number, should be unique  
        self.component = component # which component (name) this pin belongs to
        self.instance = instance   # which component (instance) this pin belongs to
        self.x = x                 # instance location
        self.y = y                 # instance location
        self.flip = flip           # instance flip, True / False
        self.rotate = rotate       # instance rotation, 0, 90, 180, 270
        self.library = library     # compact model library
        self.nets = []             # nets connected to component
        self.npins = 0             # number of pin
        self.pins = []             # an array of all the pins
        
# definition for the optical waveguide class
class Optical_waveguide:
    n = 0
    def __init__(self, points, radius, length, wg_type, num_points, wg_width, bend_pts):
        Optical_waveguide.n += 1
        self.n = Optical_waveguide.n   # waveguide number, needs to be unique
        self.points = points      # array of vertices, in database units
        self.radius = radius      # radius, in microns
        self.length = length      # length, in microns
        self.wg_type = wg_type    # wg_type: 0: path, 1: ROUND_PATH
        self.num_points = num_points # number of vertices in the path
        self.wg_width = wg_width  # waveguide width
        self.bend_pts = bend_pts  # number of points in a bend, per circle
        self.net1 = 0             # nets; one at each end of the waveguide
        self.net2 = 0             # nets; one at each end of the waveguide
        self.component = "ebeam_wg_strip_1550"  # waveguide model name
        self.library = "custom/EBeam"           # compact model library

class Optical_pin:
    n = 0
    def __init__(self, points, component_n, x, y):
        Optical_pin.n += 1
        self.n = Optical_pin.n          # pin number, must be unique
        self.points = points            # array of vertices, in database units
        self.component_n = component_n  # which component this pin belongs to
        self.net = 0                    # which net this pin is connected to
        self.x = x                      # x coordinate, in database units
        self.y = y                      # y coordinate, in database units

class Optical_net:
    net = 0
    def __init__(self, pin1_type, pin1_n, pin2_type, pin2_n):
        Optical_net.net += 1
        self.net = Optical_net.net      # net number, needs to be unique
        # an optical net can only connect to two pins. 
        # the pin variables point to either Optical_waveguide or Optical_component classes
        self.pin1_type = pin1_type      # pin type: 0 = waveguide, 1 = component, 2 = opticalIO
        self.pin1_n = pin1_n            # pin n: component or waveguide number
        self.pin2_type = pin2_type
        self.pin2_n =pin2_n

class Layout_error:
    # for keeeping track of layout errors
    n = 0
    def __init__(self, text, x, y):
        Layout_error.n += 1
        self.text = text              # error text
        self.x = x                    # error location
        self.y = y                    # error location




def distance_xy ( p1, p2 ):
  # calculate the distance between two points
  # input in dbu
  # output in microns
  distance = math.sqrt ( (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 ) * dbu  
  return distance

def find_wg_connectivity(optical_nets, optical_pins):
  # go through all the optical nets and pins, and determine which ones are connected to one another
  return 0



def points_per_circle(radius):
  # Calculate the recommended number of points in a circle, based on 
  # http://stackoverflow.com/questions/11774038/how-to-render-a-circle-with-as-few-vertices-as-possible
  # radius in microns
  import numpy as n
  error=0.5e-3 # 0.5 nm
  th = n.arccos(2 * (1 - error / radius)**2 - 1)
  num_vertices = n.ceil(2*n.pi/th)
  return num_vertices

def flag_waveguide_error(dpoints, text, optical_waveguide, topcell):
  # global variable "layout_errors" of class "Layout_error" used for storing all the errors.
  a1 = []
  for p in dpoints:
    a1.append (pya.Point(p[0], p[1]))
  path = pya.Path(a1, optical_waveguide.wg_width*4/dbu)
  topcell.shapes(LayerErrorN).insert(path)
  x = numpy.array(dpoints)[:,0].mean()*dbu
  y = numpy.array(dpoints)[:,1].mean()*dbu
  layout_errors.append(Layout_error(text, x, y) )
  print text
  wtext.insertHtml('%s&lt;br&gt;' %text)


def check_waveguides(optical_waveguides, topcell, error_layer):
  # check waveguides for basic errors.
  num_errors=0

  for o in optical_waveguides:
    found_error = False

    # Check for paths with &gt; 2 vertices
    if (o.wg_type == 0 and o.num_points &gt; 2):
      text = "  *** Layout error.  Waveguide path (%s, %s): Only 2 points allowed in a path. Convert to a waveguide (ROUND_PATH) if necessary. " \
            % ( o.points[0][0]*dbu, o.points[0][1]*dbu) 
      dpoints=n.array(o.points)
      found_error = True
      flag_waveguide_error(dpoints, text, o, topcell)

    # find the minimum segment to make sure that the bends have large enough radius
    if (o.wg_type == 1):
      # first segment:
      segment = distance_xy ( o.points[0], o.points[1] ) 
      if segment &lt; o.radius:
        text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s)." % (segment, o.radius)
        dpoints=n.array([ o.points[0], o.points[1] ] )
        found_error = True 
        flag_waveguide_error(dpoints, text, o, topcell)
      # last segment:
      segment = distance_xy ( o.points[len(o.points)-2], o.points[len(o.points)-1] ) 
      if segment &lt; o.radius:
        text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s)." % (segment, o.radius)
        dpoints=n.array([ o.points[len(o.points)-2], o.points[len(o.points)-1] ] )
        flag_waveguide_error(dpoints, text, o, topcell)
        found_error = True
      # go through each of the middle segments:
      for j in range(1, len(o.points)-2):
        segment = distance_xy ( o.points[j], o.points[j+1] ) 
        if segment &lt; o.radius:
          text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s)." % (segment, o.radius)
          dpoints=n.array([ o.points[j], o.points[j+1] ] )
          flag_waveguide_error(dpoints, text, o, topcell)
          found_error = True

      # Check for waveguides with too few bend points
      recommended_points = points_per_circle(o.radius)
      if o.bend_pts &lt; 0.75 * recommended_points:
        text =  "  *** Layout warning.  Waveguide bends should have at least %s points per circle for a %s micron radius." \
                     % (int(recommended_points), o.radius)
        dpoints=n.array(o.points)
        found_error = True
        flag_waveguide_error(dpoints, text, o, topcell)
              



def find_all_waveguides(cell, layer):
  # function to traverse the entire layout hierarchy and find all the waveguides 
  # returns array listing all paths
  # Search for ROUND_PATH PCells and straight paths

  # return data containing:
  # - net id: unique identifier for the net
  # - vertices: points that make up the path

  dbu = cell.layout().dbu
  
  iter = cell.begin_shapes_rec(layer)
  i=0
  while not(iter.at_end()):
    i+=1
    found_wg = False
    
    if iter.shape().is_path():
      # This is a waveguide that is a path.  It should be only a straight line with no bends
      path_obj= iter.shape()
      wg_path = path_obj.path
      num_points = path_obj.path.num_points()
      if num_points == 2:
        # insert a mid-point in the waveguide, so that it can later be split into two nets
        points = path_to_points(path_obj)
        a1 = []
        count =0
        for p in points:
          a1.append (pya.Point(p[0], p[1]))
          count += 1
          if count == 1:
            # add a point:
            a1.append( pya.Point( (points[0][0] + points[1][0])/2, (points[0][1] + points[1][1])/2 )  )
        wg_path = pya.Path(a1, path_obj.path.width)
      path = wg_path.transformed(iter.itrans())   # get the path description        
#      path= path_obj.path.transformed(iter.itrans())   # get the path description        
      # Waveguide parameters
      radius = 0
      length =  path.length()*dbu
      wg_type = 0
      bend_pts = 0
      wg_width = path.width*dbu
      print "Waveguide #%s: In cell {%s}, num_points: %s, length: %s, radius: %s, path: %s"   % (i, iter.cell().name, num_points, length, radius, path)
      found_wg = True
      
    if iter.shape().is_polygon():
      if iter.cell().basic_name() == "ROUND_PATH":
        # This is a waveguide implemented using a PCell ROUND_PATH
        subcell = iter.cell()        
#        polygon = iter.shape().polygon.transformed(iter.itrans())
        # Get the waveguide guiding shape path from the "ROUND_PATH" PCell 
        DPath = subcell.pcell_parameters_by_name()["path"]*(1/dbu)  # DPath object
        ipath = pya.Path.from_dpath(DPath)  # Construct an integer-coordinate path from a floating-point coordinate one

        # Find out the transformation that needs to be performed on the path relative to the top cell
        # and apply this on the waveguide guiding shape path
        trans = iter.trans() # CplxTrans object of the instance 
        DCplxTrans = pya.DCplxTrans.from_itrans(trans) # need CplxTrans to DCplxTrans
        path = DPath.transformed(DCplxTrans)

        # Waveguide parameters
        radius = subcell.pcell_parameters_by_name()["radius"]  # in microns
        bend_pts = subcell.pcell_parameters_by_name()["npoints"] 
        length =  path.length()*dbu
        num_points = path.num_points()
        wg_type = 1
        wg_width = 0.5  # no way to get it from the ROUND_PATH PCell yet  # in microns
        print "Waveguide #%s: In cell {%s}, num_points: %s, length: %s, radius: %s, path: %s"   % (i, subcell.name, num_points, length, radius, path)
        found_wg = True

    if found_wg:
      points = path_to_points(path)  
      # save waveguide info into the Optical_waveguide
      optical_waveguides.append ( Optical_waveguide (  points, radius, length, wg_type, num_points, wg_width, bend_pts ) )


    iter.next()
  print " "

def path_to_points(path):
  # function to convert a KLayout Path object to an array of points
  # iterate through all the points in the path, and 
  p_iter = path.each_point()
  points = []
  try:
    while True:
       p = p_iter.next()
       points.append( [int(p.x), int(p.y)] )
  except StopIteration:
    pass    
  return points

def check_components(cell, LayerDevRecN):
  # function to go through all the cells
  # check that the cell has at most ONE DevRec shape.  
  print " "




  
def find_all_components(cell, LayerDevRecN, LayerPinRecN, LayerFbrTgtN):
  # function to traverse the entire layout hierarchy and find all the components
  # returns list of components, location, orientation
  # use the DevRec shapes.  One DevRec shape per component.
  
  # Find all the DevRec shapes; identify the component it belongs; record the instance info as an Optical_component 
  # for each component instance, also find the Pins and Fibre ports.

  # Find all the DevRec shapes
  iter1 = cell.begin_shapes_rec(LayerDevRecN)
  i=0
  while not(iter1.at_end()):
    i+=1
    subcell = iter1.cell()                     # cell (component) to which this shape belongs
    component = subcell.basic_name()   # name library component
    instance = subcell.name      
    subcell.name                # name of the cell; for PCells, different from basic_name
    found_component = False
    # DevRec must be either a Box or a Polygon:
    if iter1.shape().is_box():
      box= iter1.shape().box.transformed(iter1.itrans())
      print "%s: DevRec in cell {%s}, box -- %s; %s"   % (i, subcell.basic_name(), box.p1, box.p2)
      found_component = True
    if iter1.shape().is_polygon():
      polygon = iter1.shape().polygon.transformed(iter1.itrans())
      print "%s: DevRec in cell {%s}, polygon -- %s"   % (i, subcell.basic_name(), polygon)
      found_component = True

    # A component was found. record the instance info as an Optical_component 
    if found_component:
      library = "library/EBeam"
      x = iter1.itrans().disp.x*dbu
      y = iter1.itrans().disp.y*dbu
      flip = iter1.trans().is_mirror()
      rotate = iter1.trans().rot()
      optical_components.append ( Optical_component (component, instance, x, y, flip, rotate, library) )
      component_n = optical_components[len(optical_components)-1].n
      
      # Find the PinRec and FbrTgt, and record info as Optical_pin
      iter2 = subcell.begin_shapes_rec(LayerPinRecN)
      while not(iter2.at_end()):
        if iter2.shape().is_path():
          path= iter2.shape().path.transformed(iter2.itrans())
          path= path.transformed(iter1.itrans())
          points = path_to_points(path)  
          x = points[0][0]
          y = points[0][1]
          optical_pins.append (Optical_pin (points, component_n, x, y) )
          optical_components[component_n-1].npins += 1
          optical_components[component_n-1].pins.append(len(optical_pins)-1)
          print "%s: PinRec in cell {%s}, path -- %s"   % (i, iter2.cell().name, path)
        iter2.next()
      iter2 = subcell.begin_shapes_rec(LayerFbrTgtN)
      while not(iter2.at_end()):
        if iter2.shape().is_polygon():
          polygon = iter2.shape().polygon.transformed(iter2.itrans())
          polygon = polygon.transformed(iter1.itrans())
          # What do we want to do with the Fibre ports?
          # create a net (with only 1 member = the optical IO)
          optical_nets.append ( Optical_net (2, component_n, -1, -1) )
          optical_components[component_n-1].nets.append( len(optical_nets) )
          optical_components[component_n-1].npins += 1
        iter2.next()
        
    # end if found_component   
     
    iter1.next()
 
  # end while iter1
  
  check_components(cell, LayerDevRecN)

# end def find_all_components


def check_point_in_segment(a, b, c):
    """ How can you determine a point is between two other points on a line segment?
    http://stackoverflow.com/questions/328107/how-can-you-determine-a-point-is-between-two-other-points-on-a-line-segment
    by Cyrille Ka.  Check if c is between a and b? """
    crossproduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y)
    if abs(crossproduct) != 0 : return False 
    dotproduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y)*(b.y - a.y)
    if dotproduct &lt; 0 : return False
    squaredlengthba = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y)
    if dotproduct &gt; squaredlengthba: return False
    return True

def check_segments_colinear_overlapping( segment1, segment2 ):
  """ 
  we want to identify ONLY the following situation:
        X  O  X  O
  where XX is a segment, and OO is another segment
  namely, colinear, but also XX overlapping OO
  example usage: 
    a = pya.Point(0,0)
    b = pya.Point(50,0)
    c = pya.Point(50,0)
    d = pya.Point(100,0)
    segment1 = [ a, b ]
    segment2 = [ c, d ]
    print check_segments_colinear_overlapping( segment1, segment2 )
  """  
  # check for one of the segment2 points being inside segment1
  check_between1 = check_point_in_segment( segment1[0], segment1[1], segment2[0] ) | \
                  check_point_in_segment( segment1[0], segment1[1], segment2[1] )
  # check for one of the segment1 points being inside segment2
  check_between2 = check_point_in_segment( segment2[0], segment2[1], segment1[0] ) | \
                  check_point_in_segment( segment2[0], segment2[1], segment1[1] )
  return check_between1 and check_between2


def identify_all_nets(optical_pins, optical_waveguides, optical_components):
  # function to identify all the nets from the layout
  # use the data in Optical_pin, Optical_waveguide to find overlaps
  # and save results in Optical_component

  # Make sure that there are exactly 2 pins for each net (not like in electronics!)

  # Loop through all the pins (p1)
  # - find other overlapping pins (p2)
  # - find overlapping waveguide ends
  for p1 in optical_pins:
    segment1 = [ pya.Point(*p1.points[0]), pya.Point(*p1.points[1]) ] 
    for p2 in optical_pins[ p1.n: len(optical_pins) ]:
      #print "%s, %s, %s, %s" % (p1.n, p1.points, p2.n, p2.points)
      segment2 = [ pya.Point(*p2.points[0]), pya.Point(*p2.points[1]) ] 
      check = check_segments_colinear_overlapping( segment1, segment2 )
      if check:  # found connected pins:
        # make a new optical net
        optical_nets.append ( Optical_net (1, p1.component_n, 1, p2.component_n) )
        net = len(optical_nets)
        # assign this net number to the components
        optical_components[p1.component_n-1].nets.append (net)
        optical_components[p2.component_n-1].nets.append (net)
        # assign this net number to the pins
        p1.net = net
        p2.net = net
        #print "connected pin, net: %s, component #: %s, %s" % (net, p1.component_n, p2.component_n)
    for w1 in optical_waveguides:
      # examine the beginning of the waveguide:
      segment2 = [ pya.Point(*w1.points[0]), pya.Point(*w1.points[1]) ] 
      check1 = check_segments_colinear_overlapping( segment1, segment2 )
      if check1:  # found connected pins:
        # make a new optical net
        optical_nets.append ( Optical_net (1, p1.component_n, 0, w1.n) )
        net = len(optical_nets)
        # assign this net number to the components
        optical_components[p1.component_n-1].nets.append (net)
        if optical_waveguides[w1.n-1].net1 &lt;&gt; 0:
          # problem. Net is already assigned.
          text = "  *** Connectivity error.  Net is already assigned (pin to waveguide). Overwriting."
          flag_waveguide_error( [w1.points[0], w1.points[1]], text, optical_waveguides[w1.n-1], topcell)
        optical_waveguides[w1.n-1].net1 = net
        # assign this net number to the pin
        p1.net = net
        
      # examine the end of the waveguide:
      np = len(w1.points)
      segment2 = [ pya.Point(*w1.points[np-2]), pya.Point(*w1.points[np-1]) ] 
      check2 = check_segments_colinear_overlapping( segment1, segment2 )
      if check2:  # found connected pins:
        # make a new optical net
        optical_nets.append ( Optical_net (1, p1.component_n, 0, w1.n) )
        net = len(optical_nets)
        # assign this net number to the components
        optical_components[p1.component_n-1].nets.append (net)
        if optical_waveguides[w1.n-1].net2 &lt;&gt; 0:
          # problem. Net is already assigned.
          text = "  *** Connectivity error.  Net is already assigned (pin to waveguide). Overwriting."
          flag_waveguide_error([w1.points[len(w1.points)-1], w1.points[len(w1.points)-2]], \
                  text, optical_waveguides[w1.n-1], topcell)
        optical_waveguides[w1.n-1].net2 = net
        # assign this net number to the pin
        p1.net = net
     

  # Check for waveguide to waveguide connections, make net
  # Loop through all waveguides, and compare to all other waveguides
  for w1 in optical_waveguides:
    # the beginning of waveguide 1:
    w1_segment1 = [ pya.Point(*w1.points[0]), pya.Point(*w1.points[1]) ] 
    # the end of waveguide 2:
    np = len(w1.points)
    w1_segment2 = [ pya.Point(*w1.points[np-2]), pya.Point(*w1.points[np-1]) ] 
    for w2 in optical_waveguides[ w1.n: len(optical_waveguides) ]:
      # the beginning of waveguide 2:
      w2_segment1 = [ pya.Point(*w2.points[0]), pya.Point(*w2.points[1]) ] 
      # the end of waveguide 2:
      np = len(w2.points)
      w2_segment2 = [ pya.Point(*w2.points[np-2]), pya.Point(*w2.points[np-1]) ] 

      # check 4 possibilities:
      for j in range(0,2):
        if j==0:
          w1_seg=w1_segment1
        else:
          w1_seg=w1_segment2
        for k in range(0,2):
          if k==0:
            w2_seg=w2_segment1
          else:
            w2_seg=w2_segment2
            
          # perform comparison between each of the waveguide ends:
          check = check_segments_colinear_overlapping( w1_seg, w2_seg )
          if check:  # found connected pins:
            # make a new optical net
            optical_nets.append ( Optical_net (0, w1.n, 0, w2.n) )
            net = len(optical_nets)
            if j==0:
              optical_waveguides[w1.n-1].net1 = net
            else:
              optical_waveguides[w1.n-1].net2 = net
            if k==0:
              optical_waveguides[w2.n-1].net1 = net
            else:
              optical_waveguides[w2.n-1].net2 = net



# end def identify_all_nets



def flag_component_error(box, text, x, y):
  # global variable "layout_errors" of class "Layout_error" used for storing all the errors.
  topcell.shapes(LayerErrorN).insert(box)
  layout_errors.append(Layout_error(text, x, y) )
  print text
  wtext.insertHtml('%s&lt;br&gt;' %text)


def check_connectivity(optical_components, topcell, LayerErrorN):
  # Make sure that all pins/waveguides are connected, i.e., dangling pins/waveguides.
  # Flag disconnected pins
  # Flag disconnected waveguides

  for k in range(0,len(optical_components)):
    if optical_components[k].npins &lt;&gt; len(optical_components[k].nets):
      text = "  *** Connectivity error.  Mismatch between the number of pins (%s) on the component (%s, %s) at (%s, %s), and the number of nets (%s)." \
            % ( optical_components[k].npins, optical_components[k].component, optical_components[k].n, \
                optical_components[k].x, optical_components[k].y, len(optical_components[k].nets) )
      bbox = layout.cell(optical_components[k].instance).bbox()
      box = bbox.transformed(pya.Trans(optical_components[k].rotate, optical_components[k].flip, \
                optical_components[k].x/dbu,optical_components[k].y/dbu))
      flag_component_error(box, text, optical_components[k].x, optical_components[k].y)

      # go through all the pins in the component, and check if they aren't assigned to a net
      for m in range(0,optical_components[k].npins):
        pin = optical_pins[optical_components[k].pins[m]]
        if pin.net == 0:
          text = "  *** Found disconnected pin at (%s, %s)" % (pin.x*dbu, pin.y*dbu)
          box = pya.Box(pin.x-3000, pin.y-3000, pin.x+3000, pin.y+3000)
#          flag_component_error(box, text, pin.x*dbu, pin.y*dbu)

  for pin in optical_pins:
    if pin.net == 0:
      text = "  *** Found disconnected pin at (%s, %s)" % (pin.x*dbu, pin.y*dbu)
      box = pya.Box(pin.x-3000, pin.y-3000, pin.x+3000, pin.y+3000)
      flag_component_error(box, text, pin.x*dbu, pin.y*dbu)

  for w1 in optical_waveguides:
    # examine the beginning of the waveguide:
    if w1.net1 == 0:
      text = "  *** Found disconnected waveguide at (%s, %s)" \
          % (w1.points[0][0]*dbu, w1.points[0][1]*dbu)
      flag_waveguide_error( [w1.points[0], w1.points[1]], text, optical_waveguides[w1.n-1], topcell)
    # examine the end of the waveguide:
    if w1.net2 == 0:
      text = "  *** Found disconnected waveguide at (%s, %s)" \
          % (w1.points[len(w1.points)-1][0]*dbu, w1.points[len(w1.points)-1][1]*dbu)
      flag_waveguide_error([w1.points[len(w1.points)-1], w1.points[len(w1.points)-2]], \
               text, optical_waveguides[w1.n-1], topcell)



def list_optical_components(optical_components):
  # list all Optical_component objects from an array
  # input array, optical_components
  # example output:         
  # X_grating_coupler_1 N$7 N$6 grating_coupler library="custom/genericcml" sch_x=-1.42 sch_y=-0.265 sch_r=0 sch_f=false

  for o in optical_components:
    nets_str = ""
    for n in o.nets:
      nets_str += " N$" + str(n)
    flip = 'true' if o.flip else 'false'
    rotate = str(o.rotate)
    t = '%s %s %s library="%s" lay_x=%s lay_y=%s sch_x=%s sch_y=%s sch_r=%s sch_f=%s'  % \
         ( "X"+o.component+"_"+str(o.n), nets_str, o.component, o.library, str (o.x * 1e-6), o.y * 1e-6, o.x, o.y, rotate, flip)
    print t
    wtext.insertHtml('%s&lt;br&gt;' %t)

def list_optical_waveguides(list_optical_waveguides):
  # list all Optical_component objects from an array
  # input array, optical_components
  # example output:         
  # X5 9 10 ebeam_wg_strip_1550 library="custom/EBeam" wg_length=7.86299e-06 wg_width=5.085e-07 sch_x=-1.42 sch_y=-0.265

  for o in list_optical_waveguides:
    nets_str = "N$%s N$%s" %(o.net1, o.net2)
    x = numpy.array(o.points)[:,0].mean()*dbu
    y = numpy.array(o.points)[:,1].mean()*dbu
    t = '%s %s %s library="%s" wg_length=%s wg_width=%s lay_x=%s lay_y=%s sch_x=%s sch_y=%s'  % \
           ( "Xwg" + str(o.n), nets_str, o.component, o.library, o.length*1e-6, o.wg_width*1e-6, str (x * 1e-6), y * 1e-6, x, y)
    print t
    wtext.insertHtml('%s&lt;br&gt;' %t)








# Configure variables to draw structures in the presently selected cell:
lv = pya.Application.instance().main_window().current_view()
if lv == None:
  raise Exception("No view selected")
# Find the currently selected layout.
layout = pya.Application.instance().main_window().current_view().active_cellview().layout() 
if layout == None:
  raise Exception("No layout")
# find the currently selected cell:
topcell = pya.Application.instance().main_window().current_view().active_cellview().cell
if topcell == None:
  raise Exception("No cell")
# fetch the database parameters
dbu = layout.dbu



def gen_ui():
  global wdg
  if 'wdg' in globals():
    if wdg is not None and not wdg.destroyed():
      wdg.destroy()
  global wtext

  def button_clicked(checked):
    """ Event handler: "OK" button clicked """
    wdg.destroy()

  wdg = pya.QDialog(pya.Application.instance().main_window())

  wdg.setAttribute(pya.Qt.WA_DeleteOnClose)
  wdg.setWindowTitle("SiEPIC-EBeam-PDK Verification and Netlist Generation")

  wdg.resize(1000, 500)
  wdg.move(1, 1)

  grid = pya.QGridLayout(wdg)

  windowlabel1 = pya.QLabel(wdg)
  windowlabel1.setText("Verification output:")
  wtext = pya.QTextEdit(wdg)
  wtext.enabled = True
  wtext.setText('')

  ok = pya.QPushButton("OK", wdg)
  ok.clicked(button_clicked)   # attach the event handler
  netlist = pya.QPushButton("Netlist Export", wdg) # not implemented

  grid.addWidget(windowlabel1, 0, 0, 1, 3)
  grid.addWidget(wtext, 1, 1, 3, 3)
  grid.addWidget(netlist, 4, 2)
  grid.addWidget(ok, 4, 3)

  grid.setRowStretch(3, 1)
  grid.setColumnStretch(1, 1)

  wdg.show()

def make_test_layout(cell, layer):
  delete_extra_top_cells()
  cell.layout().prune_subcells(cell.cell_index(), 10)
  points = [ [0,0], [10,0], [10,10] ]

  cell1 = cell.layout().create_cell("level1")
  trans = pya.Trans(pya.Trans.R90, 0, 0)
  cell.insert(pya.CellInstArray(cell1.cell_index(), trans))
  
  cell2 = cell.layout().create_cell("level2")
  layout_waveguide_abs(cell2, layer, points, 0.5, 3)
  trans = pya.Trans(pya.Point(3000,3000))
  cell1.insert(pya.CellInstArray(cell2.cell_index(), trans))



# ************************************************************************
# ************************************************************************
#  Main script:
# ************************************************************************
# ************************************************************************

# Create a GUI for the output:
gen_ui()
print(wdg)
wtext.insertHtml('Running SiEPIC-EBeam-PDK Verification and Netlist Generation.&lt;br&gt;')

# Define layers based on PDK_functions:
SiLayerN = layout.layer(SiLayer)
LayerTextN = layout.layer(LayerText)
LayerPinRecN = layout.layer(LayerPinRec)
LayerDevRecN = layout.layer(LayerDevRec)
LayerFbrTgtN = layout.layer(LayerFbrTgt)
LayerErrorN = layout.layer(LayerError)

# Clear the previous errors:
clear_ErrorLayer(topcell, LayerErrorN)

# optional - make a test layout
#make_test_layout(topcell, SiLayer)

# initialize the arrays to keep track of layout objects
optical_components = []
optical_waveguides = []
optical_pins = []
optical_nets = []

# Search the layout for the components and waveguides:
print "* calling find_all_components() – DevRec"
find_all_components(topcell, LayerDevRecN, LayerPinRecN, LayerFbrTgtN)
print "* calling find_all_waveguides()"
find_all_waveguides(topcell, SiLayerN)

# Search the arrays to identify all the nets:
identify_all_nets(optical_pins, optical_waveguides, optical_components)

# Check the layout for errors, using the above arrays:
print ""
print "Checking layout for errors: "
wtext.insertHtml('&lt;br&gt;* Checking layout for errors:&lt;br&gt;&lt;br&gt;')
layout_errors=[]
# Check waveguides for waveguide-specific problems:
check_waveguides(optical_waveguides, topcell, LayerErrorN)
# Check connectivity between components and waveguides:
check_connectivity(optical_components, topcell, LayerErrorN)
lv.add_missing_layers()
print "*** Number of errors found: %s." % len(layout_errors)
wtext.insertHtml('&lt;br&gt;*** Number of errors found: %s.&lt;br&gt;' % len(layout_errors) )


# Output the Spice netlist:
wtext.insertHtml('&lt;br&gt;* Spice netlist output:&lt;br&gt;&lt;br&gt;')
print ""
print "Spice output: "
print ""
list_optical_components(optical_components)
list_optical_waveguides(optical_waveguides)

# Find the automated measurement coordinates:
wtext.insertHtml('&lt;br&gt;* Automated measurement coordinates:&lt;br&gt;&lt;br&gt;')
print ""
print "Automated measurement coordinates: "
print ""
t = find_automated_measurement_labels(topcell, LayerTextN)
wtext.insertHtml (t)

# Done
wtext.insertHtml('&lt;br&gt;Done.&lt;br&gt;')
print ""
print "Done. "
print ""



</text>
</klayout-macro>
