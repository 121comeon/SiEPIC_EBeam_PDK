<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>SiEPIC EBeam PDK functions</description>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># Python script
# SiEPIC_EBeam_functions

"""
This file is part of the SiEPIC_EBeam_PDK
by Lukas Chrostowski (c) 2015

This Python file implements various functions for the SiEPIC_EBeam_PDK 


NOTE: after changing the code, the macro needs to be rerun to install the new
implementation. The macro is also set to "auto run" these definitions and functions 
when KLayout is run.

Version history:

Lukas Chrostowski           2015/11/13
 - SiEPIC-EBeam-PDK Layer table 
 - Clear errors function
 - delete_extra_top_cells
 - function to delete extra cells
    def delete_extra_top_cells():
 - find all the automated measurement labels

Lukas Chrostowski           2015/11/15
 - fix for Python 3.4: print ("xxx")
 - moved some functions from SiEPIC_EBeam_Verification, so they are accessible elsewhere.

Lukas Chrostowski           2015/11/16
 - fixes for component pin_type = Optical IO / FbrTgt being incorrectly handled; added Optical_pin.pin_type

Lukas Chrostowski           2015/11/17
 - debugging &amp; fixing Verification problems
   - Optical_*.n replaced with .index, and starting from 0. -1 for undefined/disconnected.
   - added functions for listing:
     print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets)
     print_Optical_components(optical_components)
     print_Optical_waveguides(optical_waveguides)
     print_Optical_pins(optical_pins)
     print_Optical_nets(optical_nets)
 - improvements to Spice output, engineering format
 - extensive testing of verification, including large test layout
 - several floating point issues
  
"""
import pya

# SiEPIC-EBeam-PDK Layers:
SiLayer = pya.LayerInfo(1, 0)
LayerText = pya.LayerInfo(10, 0)
LayerPinRec = pya.LayerInfo(69, 0)
LayerDevRec = pya.LayerInfo(68, 0)
LayerFbrTgt = pya.LayerInfo(81, 0)
LayerError = pya.LayerInfo(999,0)
    
# definition of classes for Verification, Waveguide making, Waveguide Healing
# one for each instance of the components
class Optical_component:
    def __init__(self, index, component, instance, x, y, flip, rotate, library):
        self.index = index         # component index, should be unique, 0, 1, 2, ...
        self.component = component # which component (name) this pin belongs to
        self.instance = instance   # which component (instance) this pin belongs to
        self.x = x                 # instance location
        self.y = y                 # instance location
        self.flip = flip           # instance flip, True / False
        self.rotate = rotate       # instance rotation, 0, 90, 180, 270
        self.library = library     # compact model library
        self.nets = []             # nets connected to component
        self.npins = 0             # number of pin
        self.pins = []             # an array of all the pins

def print_Optical_components(optical_components):
  print ("Optical_components:")
  for o in optical_components:
    print ("#%s: %s / %s, (%s, %s), nets %s, npins %s, pins %s" %\
        (o.index, o.component, o.instance, o.x, o.y, o.nets, o.npins, o.pins) )
        
# definition for the optical waveguide class
class Optical_waveguide:
    def __init__(self, index, points, radius, length, wg_type, num_points, wg_width, bend_pts):
        self.index = index        # waveguide index, should be unique, 0, 1, 2, ...
        self.points = points      # array of vertices, in database units
        self.radius = radius      # radius, in microns
        self.length = length      # length, in microns
        self.wg_type = wg_type    # wg_type: 0: path, 1: ROUND_PATH
        self.num_points = num_points # number of vertices in the path
        self.wg_width = wg_width  # waveguide width
        self.bend_pts = bend_pts  # number of points in a bend, per circle
        self.net1 = -1             # nets; one at each end of the waveguide
        self.net2 = -1             # nets; one at each end of the waveguide
        self.component = "ebeam_wg_strip_1550"  # waveguide model name
        self.library = "Design kits/ebeam_v1.0" # compact model library

def print_Optical_waveguides(optical_waveguides):
  print ("Optical_waveguides:")
  for o in optical_waveguides:
    print ("#%s: length %s, type %s, net1: %s, net2: %s, points: %s" %\
        (o.index, o.length, o.wg_type, o.net1, o.net2, o.points) )

class Optical_pin:
    def __init__(self, index, points, component_n, x, y, pin_type):
        self.index = index              # pin number, index, should be unique, 0, 1, 2, ...
        self.points = points            # array of vertices, in database units
        self.component_n = component_n  # which component index this pin belongs to
        self.net = -1                    # which net this pin is connected to
        self.x = x                      # x coordinate, in database units
        self.y = y                      # y coordinate, in database units
        self.pin_type = pin_type        # pin type: 0 = waveguide, 1 = component, 2 = opticalIO

def print_Optical_pins(optical_pins):
  print ("Optical_pins:")
  for o in optical_pins:
    if o.pin_type == 1:
      points = o.points
    else:
      points = "..."
    print ("#%s: component_n %s, pin_type %s, net: %s, (%s, %s), points: %s" %\
        (o.index, o.component_n, o.pin_type, o.net, o.x, o.y, points) )

class Optical_net:
    def __init__(self, index, pin1_type, pin1_n, pin2_type, pin2_n):
        self.index = index              # net number, index, should be unique, 0, 1, 2, ...
        # an optical net can only connect to two pins. 
        # the pin variables point to either Optical_waveguide or Optical_component classes
        self.pin1_type = pin1_type      # pin type: 0 = waveguide, 1 = component, 2 = opticalIO
        self.pin1_n = pin1_n            # pin n: component or waveguide index
        self.pin2_type = pin2_type
        self.pin2_n = pin2_n

def print_Optical_nets(optical_nets):
  print ("Optical_nets:")
  for o in optical_nets:
    if o.pin1_type != 0:
      name1 = optical_components[o.pin1_n].component
    else:
      name1 = 'waveguide'
    if o.pin2_type != 0:
      name2 = optical_components[o.pin2_n].component
    else:
      name2 = 'waveguide'
    print ("#%s: pin1: %s (%s) pin_type1: %s; pin2: %s (%s) pin_type2: %s" %\
        (o.index, o.pin1_n, name1, o.pin1_type, o.pin2_n, name2, o.pin2_type) )

def print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets):
  print_Optical_components(optical_components)
  print_Optical_waveguides(optical_waveguides)
  print_Optical_pins(optical_pins)
  print_Optical_nets(optical_nets)

class Layout_error:
    # for keeeping track of layout errors
    n = 0
    def __init__(self, text, x, y):
        Layout_error.n += 1
        self.text = text              # error text
        self.x = x                    # error location
        self.y = y                    # error location

def reset_Optical_classes():
  Layout_error.n = 0


# Clear the error markers generated by SiEPIC_EBeam_Verification
def clear_ErrorLayer(topcell, LayerErrorN):
  iter = topcell.begin_shapes_rec(LayerErrorN)
  
  i=0
  while not(iter.at_end()):
    if iter.shape().is_path() | iter.shape().is_box():
      i+=1
      iter.shape().delete()
    iter.next()
  print ("*** Deleted %s errors.") % i


def delete_extra_top_cells():
  # delete all the extra top cells; keep the one selected

  # Find the currently selected layout.
  ly = pya.Application.instance().main_window().current_view().active_cellview().layout() 
  if ly == None:
    raise Exception("No layout")
  # find the currently selected cell:
  cell = pya.Application.instance().main_window().current_view().active_cellview().cell
  if cell == None:
    raise Exception("No cell")

  print ("deleting cells...")
  top_keep = cell.cell_index()
  top_delete = []
  for top in ly.each_top_cell():
    if top == top_keep:
        print ("keep top cell: " + str(ly.cell(top_keep).name))
    else:
        print ("delete top cell: " + str(ly.cell(top).name))
        top_delete.append(top)
  print top_delete
  ly.delete_cells(top_delete)


import string
def find_automated_measurement_labels(topcell, LayerTextN):
  # example usage:
  # topcell = pya.Application.instance().main_window().current_view().active_cellview().cell
  # LayerText = pya.LayerInfo(10, 0)
  # LayerTextN = topcell.layout().layer(LayerText)
  # find_automated_measurement_labels(topcell, LayerTextN)
  t = ''
  dbu = topcell.layout().dbu
  iter = topcell.begin_shapes_rec(LayerTextN)
  i=0
  while not(iter.at_end()):
    if iter.shape().is_text():
      text = iter.shape().text
      if string.find(text.string,"opt_in") &gt; -1:
        i+=1
        text2 = iter.shape().text.transformed(iter.itrans())
        t += "label: %s, location: (%s, %s) &lt;br&gt;" %(text.string, text2.x*dbu, text2.y*dbu )
    iter.next()
  t += "&lt;br&gt;*** Number of automated measurement labels: %s.&lt;br&gt;" % i
  return t

  
def find_all_components(cell, LayerDevRecN, LayerPinRecN, LayerFbrTgtN):
  # function to traverse the entire layout hierarchy and find all the components
  # returns list of components, location, orientation
  # use the DevRec shapes.  One DevRec shape per component.
  
  # Find all the DevRec shapes; identify the component it belongs; record the instance info as an Optical_component 
  # for each component instance, also find the Pins and Fibre ports.
  
  # Use the pin names on layer PinRec to sort the pins in alphabetical order
  #   Requires that a text label be in PinRec layer, co-linear inside the PinRec path.
  # sorting the pins uses the Pin_info class:
  class Pin_info:
    def __init__(self, pin_text, pin_x, pin_y):
      self.pin_text = pin_text
      self.pin_x = pin_x
      self.pin_y = pin_y


  # Find all the DevRec shapes
  iter1 = cell.begin_shapes_rec(LayerDevRecN)
  i=0
  while not(iter1.at_end()):
    i+=1
    subcell = iter1.cell()                     # cell (component) to which this shape belongs
    component = subcell.basic_name()   # name library component
    instance = subcell.name      
    subcell.name                # name of the cell; for PCells, different from basic_name
    found_component = False
    # DevRec must be either a Box or a Polygon:
    if iter1.shape().is_box():
      box= iter1.shape().box.transformed(iter1.itrans())
      print ("%s: DevRec in cell {%s}, box -- %s; %s"   % (i, subcell.basic_name(), box.p1, box.p2) )
      found_component = True
    if iter1.shape().is_polygon():
      polygon = iter1.shape().polygon.transformed(iter1.itrans())
      print ("%s: DevRec in cell {%s}, polygon -- %s"   % (i, subcell.basic_name(), polygon))
      found_component = True

    # A component was found. record the instance info as an Optical_component 
    if found_component:
      # Find text label for DevRec, to get Library name
      iter2 = subcell.begin_shapes_rec(LayerDevRecN)
      while not(iter2.at_end()):
        if iter2.shape().is_text():
          print ("%s: DevRec label: %s" % (i, iter2.shape().text))
        iter2.next()
      library = "Design kits/ebeam_v1.0"
      x = iter1.itrans().disp.x*dbu
      y = iter1.itrans().disp.y*dbu
      flip = iter1.trans().is_mirror()
      rotate = int(iter1.trans().rot())*90
      component_index = len(optical_components)
      optical_components.append ( Optical_component (component_index, \
                  component, instance, x, y, flip, rotate, library) )
      
      # Find the PinRec and record info as Optical_pin
      
      # Use the pin names on layer PinRec to sort the pins in alphabetical order
      # read; sort; save data.
      iter2 = subcell.begin_shapes_rec(LayerPinRecN)
      pin_info1 = []  # array for Pin_info
      path_points=[]
      path_shape=[]
      while not(iter2.at_end()):
        # Find text label for PinRec, to get the port numbers
        if iter2.shape().is_text():
          texto= iter2.shape().text.transformed(iter2.itrans())
          texto= texto.transformed(iter1.itrans())
          x = texto.x
          y = texto.y
          #print ( "PinRec label: %s at (%s, %s)" % (iter2.shape().text, x, y) )
          pin_info1.append(Pin_info(iter2.shape().text.string, x, y))
        if iter2.shape().is_path():
          path= iter2.shape().path.transformed(iter2.itrans())
          path= path.transformed(iter1.itrans())
          points = path_to_points(path)  
          x = points[0][0]
          y = points[0][1]
          #print ( "%s: PinRec in cell {%s}, path -- %s"   % (i, iter2.cell().name, path) )
          path_points.append(points)
          path_shape.append(iter2.shape())
        iter2.next()
      # Sort pin text labels
      pin_info2 = sorted(pin_info1, key=lambda  pin_info0: pin_info0.pin_text)

      # find pin labels that are inside the path:
      for p1 in range(0,len(pin_info2)):
        for p2 in range(0,len(path_shape)):
          check_text_in_pin = check_point_in_segment( \
            pya.Point( *path_points[p2][0] ), \
            pya.Point( *path_points[p2][1] ), \
            pya.Point( pin_info2[p1].pin_x, pin_info2[p1].pin_y ) )
          if check_text_in_pin:
            points = path_points[p2]  
            x = points[0][0]
            y = points[0][1]
            pin_index = len(optical_pins)
            optical_pins.append (Optical_pin (pin_index, points, component_index, x, y, 1) )
            optical_components[component_index].npins += 1
            optical_components[component_index].pins.append( pin_index )
            print ("%s: PinRec (text=%s) in cell {%s}, component #%s, path -- %s"   \
              % (i, pin_info2[p1].pin_text, iter2.cell().name, component_index, path_to_points(path_shape[p2].path)) )

      # Find the FbrTgt, and record info as Optical_pin
      iter2 = subcell.begin_shapes_rec(LayerFbrTgtN)
      while not(iter2.at_end()):
        if iter2.shape().is_polygon():
          polygon = iter2.shape().polygon.transformed(iter2.itrans())
          polygon = polygon.transformed(iter1.itrans())
          # What do we want to do with the Fibre ports?
          # create a net (with only 1 member = the optical IO)
          net_index = len(optical_nets)
          optical_nets.append ( Optical_net (net_index, 2, component_index, -1, -1) ) #ok
          # create a pin, optical IO
          bb = polygon.bbox()
          x, y = numpy.mean([bb.p1.x, bb.p2.x]), numpy.mean([bb.p1.y, bb.p2.y])
          pin_index = len(optical_pins)
          optical_pins.append (Optical_pin (pin_index, polygon_to_points(polygon), component_index, x, y, 2) )
          # register the net with the pin and component
          optical_pins[pin_index].net = net_index
          optical_components[component_index].nets.append( net_index )
          # register the pin with the component
          optical_components[component_index].npins += 1
          optical_components[component_index].pins.append( pin_index ) 
          print ("%s: FbrTgt in cell {%s}, at (%s, %s), net %s, pins %s, component # %s, component nets %s")   \
              % (i, iter2.cell().name, x, y, net_index, optical_components[component_index].pins, \
              component_index, optical_components[component_index].nets  )
        iter2.next()
        
    # end if found_component   
     
    iter1.next()
 
  # end while iter1 
# end def find_all_components


def distance_xy ( p1, p2 ):
  # calculate the distance between two points
  # input in dbu
  # output in microns
  distance = math.sqrt ( (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 ) * dbu  
  return distance


def points_per_circle(radius):
  # Calculate the recommended number of points in a circle, based on 
  # http://stackoverflow.com/questions/11774038/how-to-render-a-circle-with-as-few-vertices-as-possible
  # radius in microns
  import numpy as n
  error=0.5e-3 # 0.5 nm
  th = n.arccos(2 * (1 - error / radius)**2 - 1)
  num_vertices = n.ceil(2*n.pi/th)
  return num_vertices


def path_to_points(path):
  # function to convert a KLayout Path object to an array of points
  # iterate through all the points in the path, and construct array
  p_iter = path.each_point()
  points = []
  try:
    while True:
       p = p_iter.next()
       # assume input Integer type; need to round due to floating point issues.
       points.append( [int(round(p.x)), int(round(p.y))] )
  except StopIteration:
    pass    
  return points


def path_to_Dpoints(path):
  # function to convert a KLayout Path object to an array of points
  # iterate through all the points in the path, and 
  p_iter = path.each_point()
  points = []
  try:
    while True:
       p = p_iter.next()
       points.append( [(p.x), (p.y)] )
  except StopIteration:
    pass    
  return points

  
def points_to_Dpath(points, w):
  a1 = []
  for p in points:
    a1.append (pya.DPoint(p[0], p[1]))
  wg_path = pya.DPath(a1, w)
  return wg_path


def points_to_path(points, w):
  a1 = []
  for p in points:
    a1.append (pya.Point(p[0], p[1]))
  wg_path = pya.Path(a1, w)
  return wg_path
  
  
def polygon_to_points(polygon):
  # for some reason, you assign points to a polygon, but not read them!
  # http://www.klayout.de/doc/code/class_SimplePolygon.html
  # This function reads the points one by one and returns an array of points
  npts = polygon.to_simple_polygon().points
  ps = polygon.to_simple_polygon()
  points = []
  for k in range(0,npts):
    pt = ps.point(k)
    points.append ( [pt.x, pt.y] )
  return points
  

def check_point_in_segment(a, b, c):
    """ How can you determine a point is between two other points on a line segment?
    http://stackoverflow.com/questions/328107/how-can-you-determine-a-point-is-between-two-other-points-on-a-line-segment
    by Cyrille Ka.  Check if c is between a and b? """
    # print ( "%s, %s; %s, %s; %s, %s" % (a.x, a.y, b.x, b.y, c.x, c.y) )
    crossproduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y)
    if abs(crossproduct) != 0 : return False 
    dotproduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y)*(b.y - a.y)
    if dotproduct &lt; 0 : return False
    squaredlengthba = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y)
    if dotproduct &gt; squaredlengthba: return False
    return True


def PCell_get_parameter_list ( cell_name, library_name ):
  # function to list all the parameters &amp; defaults for a PCell
  # example usage:
  # PCell_get_parameter_list("CIRCLE", "Basic")
  print ("* def PCell_get_parameter_list ( %s, %s): ") % ( cell_name, library_name )
  lib = pya.Library.library_by_name(library_name)
  if lib == None:
    raise Exception("Unknown lib '%s'" % library_name)
  pcell_decl = lib.layout().pcell_declaration(cell_name);
  if pcell_decl == None:
     raise Exception("Unknown PCell '%s'" % cell_name)
  type2s = ['TypeBoolean', 'TypeDouble', 'TypeInt', 'TypeLayer', 'TypeList', 'TypeNone', 'TypeShape', 'TypeString']
  for p in pcell_decl.get_parameters():
    if ~p.readonly:
      print ( "Name: %s, %s, unit: %s, default: %s, description: %s%s" % \
        (p.name, type2s[p.type], p.unit, p.default, p.description, ", hidden" if p.hidden else ".") )


def PCell_get_parameters ( pcell ):
  # function to list the values for all parameters for an intantiated PCell
  # example usage:
  # ly = pya.Application.instance().main_window().current_view().active_cellview().layout() 
  # pcell = ly.create_cell("CIRCLE", "Basic", { "actual_radius": 10, "layer": pya.LayerInfo(1, 0) } )
  # PCell_get_parameters( pcell )
  print ("* def PCell_get_parameters ( %s ):") % pcell 
  print ( pcell.pcell_parameters() )
  params = pcell.pcell_parameters_by_name()
  for param in params.keys():
    print ("Parameter: %s, Value: %s") % (param, params[param])
  return params
  
  
</text>
</klayout-macro>
