<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># Python script
# SiEPIC_EBeam_PCells

"""
This file is part of the SiEPIC_EBeam_PDK
by Lukas Chrostowski (c) 2015

This Python file implements a library called "SiEPIC_EBeam_PCells" 


*******
PCells:
*******

1) Double-bus ring resonator
class TestStruct_DoubleBus_Ring(pya.PCellDeclarationHelper):
class DoubleBus_Ring(pya.PCellDeclarationHelper):
def layout_Ring(cell, layer, x, y, r, w, npoints):

Also includes additional functions:

1) code for waveguide bends:
def layout_waveguide_abs(cell, layer, points, w, radius):
def layout_waveguide_rel(cell, layer, start_point, points, w, radius):

2) function for making polygon text
def layout_pgtext(cell, layer, x, y, text, mag):

3) functions for inspecting PCell parameters
def PCell_get_parameter_list ( cell_name, library_name ):
def PCell_get_parameters ( pcell ):



NOTE: after changing the code, the macro needs to be rerun to install the new
implementation. The macro is also set to "auto run" to install the PCell 
when KLayout is run.

Version history:

Lukas Chrostowski           2015/11/05 - 2015/11/10
 - Double-bus ring resonator
 - waveguide bends
 - PCell parameter functions
 - polygon text
 - PCell calling another PCell - TestStruct_DoubleBus_Ring

Lukas Chrostowski           2015/11/14
 - fix for rounding error in "DoubleBus_Ring"

Lukas Chrostowski           2015/11/15
 - fix for Python 3.4: print ("xxx")
 
Lukas Chrostowski           2015/11/17
 - update "layout_waveguide_rel" to use the calculated points_per_circle(radius)

"""

import pya
import math
import numpy as n

def layout_waveguide_abs(cell, layer, points, w, radius):
    # create a path, then convert to a polygon waveguide with bends
    # cell: cell into which to place the waveguide
    # layer: layer to draw on
    # points: array of vertices, absolute coordinates on the current cell
    # w: waveguide width
    
    # example usage:
    # cell = pya.Application.instance().main_window().current_view().active_cellview().cell
    # LayerSi = pya.LayerInfo(1, 0)
    # points = [ [15, 2.75], [30, 2.75] ]  # units of microns.
    # layout_waveguide_abs(cell, LayerSi, points, 0.5, 10)

    points=n.array(points)
    start_point=points[0]
    points = points - start_point
    
    layout_waveguide_rel(cell, layer, start_point, points, w, radius)


def layout_waveguide_rel(cell, layer, start_point, points, w, radius):
    # create a path, then convert to a polygon waveguide with bends
    # cell: cell into which to place the waveguide
    # layer: layer to draw on
    # start_point: starting vertex for the waveguide
    # points: array of vertices, relative to start_point
    # w: waveguide width
    
    # example usage:
    # cell = pya.Application.instance().main_window().current_view().active_cellview().cell
    # LayerSi = pya.LayerInfo(1, 0)
    # points = [ [15, 2.75], [30, 2.75] ]  # units of microns.
    # layout_waveguide_rel(cell, LayerSi, points, 0.5, 10)

    
    print ("* layout_waveguide_rel(%s, %s, %s, %s)" % (cell.name, layer, w, radius) )

    ly = cell.layout() 
    dbu = cell.layout().dbu

    start_point=n.array(start_point)/dbu
    points=n.array(points)

    a1 = []
    for p in points:
      a1.append (pya.DPoint(float(p[0]), float(p[1])))
  
    wg_path = pya.DPath(a1, w)

    npoints = points_per_circle(radius)
    param = { "npoints": npoints, "radius": radius, "path": wg_path, "layer": layer }

    pcell = ly.create_cell("ROUND_PATH", "Basic", param )

    # Configure the cell location
    trans = pya.Trans(pya.Point(start_point[0], start_point[1]))

    # Place the PCell
    cell.insert(pya.CellInstArray(pcell.cell_index(), trans))




def layout_pgtext(cell, layer, x, y, text, mag):
    # example usage:
    # cell = pya.Application.instance().main_window().current_view().active_cellview().cell
    # layout_pgtext(cell, pya.LayerInfo(10, 0), 0, 0, "test", 1)

    # for the Text polygon:
    textlib = pya.Library.library_by_name("Basic")
    if textlib == None:
      raise Exception("Unknown lib 'Basic'")

    textpcell_decl = textlib.layout().pcell_declaration("TEXT");
    if textpcell_decl == None:
      raise Exception("Unknown PCell 'TEXT'")
    param = { 
      "text": text, 
      "layer": layer, 
      "mag": mag 
    }
    pv = []
    for p in textpcell_decl.get_parameters():
      if p.name in param:
        pv.append(param[p.name])
      else:
        pv.append(p.default)
    # "fake PCell code" 
    text_cell = cell.layout().create_cell("Temp_text_cell")
    textlayer_index = cell.layout().layer(layer)
    textpcell_decl.produce(cell.layout(), [ textlayer_index ], pv, text_cell)

    # fetch the database parameters
    dbu = cell.layout().dbu
    t = pya.Trans(pya.Trans.R0, x/dbu, y/dbu)
    cell.insert(pya.CellInstArray(text_cell.cell_index(), t))
    # flatten and delete polygon text cell
    cell.flatten(True)

    print ("Done layout_pgtext")


def layout_Ring(cell, layer, x, y, r, w, npoints):
    # function to produce the layout of a ring resonator
    # cell: layout cell to place the layout
    # layer: which layer to use
    # x, y: location of the origin
    # r: radius
    # w: waveguide width
    # units in microns

    # example usage.  Places the ring layout in the presently selected cell.
    # cell = pya.Application.instance().main_window().current_view().active_cellview().cell
    # layout_Ring(cell, cell.layout().layer(pya.LayerInfo(1, 0)), 0, 0, 10, 0.5, 400)


    # fetch the database parameters
    dbu = cell.layout().dbu
    
    # compute the circle
    pts = []
    da = math.pi * 2 / npoints
    for i in range(0, npoints+1):
      pts.append(pya.Point.from_dpoint(pya.DPoint((x+(r+w/2)*math.cos(i*da))/dbu, (y+(r+w/2)*math.sin(i*da))/dbu)))
    for i in range(npoints, -1, -1):
      pts.append(pya.Point.from_dpoint(pya.DPoint((x+(r-w/2)*math.cos(i*da))/dbu, (y+(r-w/2)*math.sin(i*da))/dbu)))
    
    # create the shape
    cell.shapes(layer).insert(pya.Polygon(pts))

    # end of layout_Ring


class DoubleBus_Ring(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the double bus ring resonator.
  Consists of a ring with 2 straight waveguides.
  """

  def __init__(self):

    # Important: initialize the super class
    super(DoubleBus_Ring, self).__init__()

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = pya.LayerInfo(1, 0))
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("r", self.TypeDouble, "Radius", default = 10)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("npoints", self.TypeInt, "Number of points", default = 500)     
    self.param("textpolygon", self.TypeInt, "Draw text polygon label? 0/1", default = 1)
    self.param("textl", self.TypeLayer, "Text Layer", default = pya.LayerInfo(10, 0))
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = pya.LayerInfo(69, 0))
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = pya.LayerInfo(68, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "DoubleBus_Ring(R=" + ('%.3f' % self.r) + ",g=" + ('%g' % (1000*self.g)) + ")"

  def can_create_from_shape_impl(self):
    return False
    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout

    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    
    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    TextLayerN = ly.layer(self.textl)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)

    
    # Create the ring resonator:
    layout_Ring(self.cell, LayerSiN, self.r+self.w/2, self.r+self.g+self.w, self.r, self.w, self.npoints)

    w = int(round(self.w/dbu))
    r = int(round(self.r/dbu))
    g = int(round(self.g/dbu))

    # Create the two waveguides
    wg1 = pya.Box(0, -w/2, w+2*r, w/2)
    self.cell.shapes(LayerSiN).insert(wg1)
    y_offset = 2*r + 2*g + 2*w
    wg2 = pya.Box(0, y_offset-w/2, w+2*r, y_offset+w/2)
    self.cell.shapes(LayerSiN).insert(wg2)

    # Create the pins, as short paths:
    pin_length = 200 # database units, = 0.2 microns
    
    pin = pya.Path([pya.Point(0, 0), pya.Point(pin_length, 0)], w)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = pya.Trans(0, 0)
    text = pya.Text ("pin1", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.1/dbu

    pin = pya.Path([pya.Point(w+2*r-pin_length, 0), pya.Point(w+2*r, 0)],w )
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = pya.Trans(w+2*r-pin_length, 0)
    text = pya.Text ("pin2", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.1/dbu

    pin = pya.Path([pya.Point(0, y_offset), pya.Point(pin_length, y_offset)], w)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = pya.Trans(0, y_offset)
    text = pya.Text ("pin3", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.1/dbu

    pin = pya.Path([pya.Point(w+2*r-pin_length, y_offset), pya.Point(w+2*r, y_offset)], w)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = pya.Trans(w+2*r-pin_length, y_offset)
    text = pya.Text ("pin4", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.1/dbu


    # Create the device recognition layer
    dev = pya.Box(0, -w*3, w+2*r, y_offset+w*3 )
    self.cell.shapes(LayerDevRecN).insert(dev)


    # Add a polygon text description
    if self.textpolygon:
      layout_pgtext(self.cell, self.textl, self.w, self.r+self.w, "%.3f-%g" % ( self.r, self.g), 1)

    print ("Done drawing the layout for – DoubleBus_Ring: %.3f-%g" % ( self.r, self.g) )



class TestStruct_DoubleBus_Ring(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the DoubleBus_Ring test structure with grating couplers and waveguides
  """

  def __init__(self):

    # Important: initialize the super class
    super(TestStruct_DoubleBus_Ring, self).__init__()

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Layer", default = pya.LayerInfo(1, 0))
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("r", self.TypeDouble, "Radius", default = 10)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("npoints", self.TypeInt, "Number of points", default = 500)     
    self.param("textpolygon", self.TypeInt, "Draw text polygon label? 0/1", default = 1)
    self.param("textlayer", self.TypeLayer, "Text Layer", default = pya.LayerInfo(10, 0))
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = pya.LayerInfo(69, 0))
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = pya.LayerInfo(68, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "TestStruct_DoubleBus_Ring(R=" + ('%s' % self.r) + ",g=" + ('%s' % (1000*self.g)) + ")"

  def can_create_from_shape_impl(self):
    return False

    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout

    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    cell = self.cell
    
    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    TextLayerN = ly.layer(self.textlayer)

    # Import cells from the SiEPIC GDS Library, and instantiate them

        
    # Ring resonator PCell
    r = self.r
    wg_width = self.w
    g = self.g
    y_ring = 127*3/2+r


#    pcell = ly.create_cell("DoubleBus_Ring", "SiEPIC", {"r": r, "w": wg_width, "g": g, "l": LayerSi})
#    print ( "pcell: %s, %s" % (pcell.cell_index(), ly.cell_name(pcell.cell_index()) ) )
#    t = pya.Trans(pya.Trans.R270, 10 / dbu, y_ring / dbu) 
#    instance = cell.insert(pya.CellInstArray(pcell.cell_index(), t))
#    print instance.cell_index




    lib = pya.Library.library_by_name("SiEPIC")
    if lib == None:
      raise Exception("Unknown lib 'SiEPIC'")

    pcell_decl = lib.layout().pcell_declaration("DoubleBus_Ring");
    if pcell_decl == None:
      raise Exception("Unknown PCell 'DoubleBus_Ring'")
    param = { 
      "r": r, 
      "w": wg_width, 
      "g": g,
      "silayer": LayerSi,
      "devrec": self.devrec, 
      "pinrec": self.pinrec
    }

    pv = []
    for p in pcell_decl.get_parameters():
      if p.name in param:
        pv.append(param[p.name])
      else:
        pv.append(p.default)
    # "fake PCell code" 
    pcell = ly.create_cell("Ring")
    pcell_decl.produce(ly, [ LayerSiN ], pv, pcell)
    t = pya.Trans(pya.Trans.R270, 10 / dbu, y_ring / dbu) 
    instance = cell.insert(pya.CellInstArray(pcell.cell_index(), t))


    # Grating couplers, Ports 1, 2, 3, 4 (top-down):
    GC_name = "ebeam_gc_te1550"
    GC_imported = ly.cell(GC_name)
    if GC_imported == None:
      GC_imported = ly.create_cell(GC_name, "SiEPIC-EBeam").cell_index()
    else:
      GC_imported = GC_imported.cell_index()  
    print ( "Cell: GC_imported: #%s" % GC_imported )
    t = pya.Trans(pya.Trans.R0, 0, 0)
    instance = cell.insert(pya.CellInstArray(GC_imported, t, pya.Point(0,127/dbu), pya.Point(0,0), 4, 1))
    print instance.cell_index

    # Label for automated measurements, laser on Port 2, detectors on Ports 1, 3, 4
    t = pya.Trans(0, 127*2/dbu)
    text = pya.Text ("opt_in_TE_1550_device_DoubleBusRing", t)
    shape = cell.shapes(TextLayerN).insert(text)
    shape.text_size = 3/dbu



    # Create paths for waveguides
    wg_bend_radius = 10

    # GC3 to bottom-left of ring
    points = [ [0, 127], [10,127], [10, y_ring-2*r-wg_width] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, wg_bend_radius)

    # GC4 to bottom-right of ring
    points = [ [0, 0], [10+2*r+2*g+2*wg_width,0], [10+2*r+2*g+2*wg_width, y_ring-2*r-wg_width]  ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, 20)

    # GC2 to top-right of ring
    points = [ [10,y_ring], [10, 127*2], [0,127*2] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, wg_bend_radius)

    # GC1 to top-left of ring
    points = [ [0, 127*3], [10+2*r+2*g+2*wg_width,127*3], [10+2*r+2*g+2*wg_width, y_ring] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, 20)



    print ( "Done drawing the layout for – TestStruct_DoubleBus_Ring: %.3f-%g" % (r, g) )






class TestStruct_DoubleBus_Ring2(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the DoubleBus_Ring test structure with grating couplers and waveguides
  """

  def __init__(self):

    # Important: initialize the super class
    super(TestStruct_DoubleBus_Ring2, self).__init__()

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Layer", default = pya.LayerInfo(1, 0))
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("r", self.TypeDouble, "Radius", default = 10)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("npoints", self.TypeInt, "Number of points", default = 500)     
    self.param("textpolygon", self.TypeInt, "Draw text polygon label? 0/1", default = 1)
    self.param("textlayer", self.TypeLayer, "Text Layer", default = pya.LayerInfo(10, 0))
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = pya.LayerInfo(69, 0))
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = pya.LayerInfo(68, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "TestStruct_DoubleBus_Ring2(R=" + ('%s' % self.r) + ",g=" + ('%s' % (1000*self.g)) + ")"

  def can_create_from_shape_impl(self):
    return False

    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout

    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    cell = self.cell
    
    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    TextLayerN = ly.layer(self.textlayer)

    # Import cells from the SiEPIC GDS Library, and instantiate them
        
    # Ring resonator PCell
    r = self.r
    wg_width = self.w
    g = self.g
    y_ring = 127*3/2+r

    pcell = ly.create_cell("DoubleBus_Ring", "SiEPIC", {"r": r, "w": wg_width, "g": g, "silayer": LayerSi, "devrec": self.devrec, "pinrec": self.pinrec })
    print ( "pcell: %s, %s" \
        % (pcell.cell_index(), ly.cell_name(pcell.cell_index()) ) )
    t = pya.Trans(pya.Trans.R270, 10 / dbu, y_ring / dbu) 
    instance = cell.insert(pya.CellInstArray(pcell.cell_index(), t))
    print instance.cell_index


    # Grating couplers, Ports 1, 2, 3, 4 (top-down):
    GC_name = "ebeam_gc_te1550"
    GC_imported = ly.cell(GC_name)
    if GC_imported == None:
      GC_imported = ly.create_cell(GC_name, "SiEPIC-EBeam").cell_index()
    else:
      GC_imported = GC_imported.cell_index()  
    print ("Cell: GC_imported: #%s" % GC_imported )
    t = pya.Trans(pya.Trans.R0, 0, 0)
    instance = cell.insert(pya.CellInstArray(GC_imported, t, pya.Point(0,127/dbu), pya.Point(0,0), 4, 1))
    print instance.cell_index

    # Label for automated measurements, laser on Port 2, detectors on Ports 1, 3, 4
    t = pya.Trans(0, 127*2/dbu)
    text = pya.Text ("opt_in_TE_1550_device_DoubleBusRing", t)
    shape = cell.shapes(TextLayerN).insert(text)
    shape.text_size = 3/dbu

    # Create paths for waveguides
    wg_bend_radius = 10

    # GC3 to bottom-left of ring
    points = [ [0, 127], [10,127], [10, y_ring-2*r-wg_width] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, wg_bend_radius)

    # GC4 to bottom-right of ring
    points = [ [0, 0], [10+2*r+2*g+2*wg_width,0], [10+2*r+2*g+2*wg_width, y_ring-2*r-wg_width]  ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, 20)

    # GC2 to top-right of ring
    points = [ [10,y_ring], [10, 127*2], [0,127*2] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, wg_bend_radius)

    # GC1 to top-left of ring
    points = [ [0, 127*3], [10+2*r+2*g+2*wg_width,127*3], [10+2*r+2*g+2*wg_width, y_ring] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, 20)

    print ( "Done drawing the layout for – TestStruct_DoubleBus_Ring2: %.3f-%g" % (r, g) )



class SiEPIC(pya.Library):
  """
  The library where we will put the PCell into 
  """

  def __init__(self):

    print ("Initializing SiEPIC EBeam PCells library.")
  
    # Set the description
    self.description = "EBeam PCells"
    
    # Create the PCell declarations
    self.layout().register_pcell("DoubleBus_Ring", DoubleBus_Ring())
    self.layout().register_pcell("TestStruct_DoubleBus_Ring", TestStruct_DoubleBus_Ring())
    self.layout().register_pcell("TestStruct_DoubleBus_Ring2", TestStruct_DoubleBus_Ring2())
    
    # Register us with the name "SiEPIC_EBeam_PCells".
    # If a library with that name already existed, it will be replaced then.
    self.register("SiEPIC")
 
# Instantiate and register the library
SiEPIC()



</text>
</klayout-macro>
